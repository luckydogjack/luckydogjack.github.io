<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>汇总--Leetcode刷题日记 | Lkjack</title>
  <meta name="keywords" content="">
  <meta name="description" content="汇总--Leetcode刷题日记 | Lkjack">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="页面未找到！404 Not Found：该页无法显示很抱歉，您所访问的地址不存在">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="http://example.com/404/index.html">
<meta property="og:site_name" content="Lkjack">
<meta property="og:description" content="页面未找到！404 Not Found：该页无法显示很抱歉，您所访问的地址不存在">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-10T07:51:51.000Z">
<meta property="article:modified_time" content="2022-04-10T07:57:34.637Z">
<meta property="article:author" content="Lkjack">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.1.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Lkjack</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/luckydogjack"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:1435359352@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1435359352&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(27)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="算法">
                        <i class="fold iconfont icon-right"></i>
                        
                        算法
                        <small>(21)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="算法<--->leetcode">
                                        
                                        leetcode
                                        
                                            <small>(21
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="运维">
                        
                        运维
                        <small>(6)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="27">
<input type="hidden" id="yelog_site_word_count" value="57.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://luckydogjack.github.io/">lkjack</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>并查集</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>回溯</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>邻接表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>组合</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>BFS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DFS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Kruskal</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/%E6%B1%87%E6%80%BB--Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汇总--Leetcode刷题日记">汇总--Leetcode刷题日记</span>
            <span class="post-date" title="2022-07-28 17:34:07">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/CGI%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CGI脚本学习笔记">CGI脚本学习笔记</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言学习笔记">Go语言学习笔记</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/StarProjects%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="StarProjects项目收藏文件夹的说明">StarProjects项目收藏文件夹的说明</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis学习笔记">Redis学习笔记</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL学习笔记">MySQL学习笔记</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/07/28/%E8%BF%90%E7%BB%B4/gitee%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="gitee学习笔记">gitee学习笔记</span>
            <span class="post-date" title="2022-07-28 17:32:20">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B039/"
           data-tag="DFS,组合"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记39">Leetcode刷题日记39</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0437/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记437">Leetcode刷题日记437</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0450/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记450">Leetcode刷题日记450</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046/"
           data-tag="回溯"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记46">Leetcode刷题日记46</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0684/"
           data-tag="并查集"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记684">Leetcode刷题日记684</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077/"
           data-tag="回溯"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记77">Leetcode刷题日记77</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079/"
           data-tag="回溯"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记79">Leetcode刷题日记79</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0934/"
           data-tag="BFS,DFS"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记934">Leetcode刷题日记934</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0947/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记947">Leetcode刷题日记947</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0LCP09/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LCP 09. 最小跳跃次数">LCP 09. 最小跳跃次数</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%E6%A8%A1%E6%9D%BF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记">Leetcode刷题日记</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/nowcoder%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B02016%E5%8D%8E%E4%B8%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="nowcoder真题笔记2016华为">nowcoder真题笔记2016华为</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126/"
           data-tag="BFS,DFS"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记126">Leetcode刷题日记126</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130/"
           data-tag="BFS,DFS"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记130">Leetcode刷题日记130</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B01319/"
           data-tag="DFS,邻接表,并查集"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记1319">Leetcode刷题日记1319</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B01584/"
           data-tag="并查集,Kruskal"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记1584">Leetcode刷题日记1584</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B01893.%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记1893. 检查是否区域内所有整数都被覆盖">Leetcode刷题日记1893. 检查是否区域内所有整数都被覆盖</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0198/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记198">Leetcode刷题日记198</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257/"
           data-tag="回溯"
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记257">Leetcode刷题日记257</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <a  class="全部文章 算法 leetcode "
           href="/2022/07/28/LeetCode/Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0307.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode刷题日记1893. 检查是否区域内所有整数都被覆盖">Leetcode刷题日记1893. 检查是否区域内所有整数都被覆盖</span>
            <span class="post-date" title="2022-07-28 17:13:55">2022/07/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-LeetCode/汇总--Leetcode刷题日记" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">汇总--Leetcode刷题日记</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a> > 
            
            <a  data-rel="算法&lt;---&gt;leetcode">leetcode</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-07-28 17:33:53'>2022-07-28 17:34</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:16.1k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="汇总–Leetcode刷题日记"><a href="#汇总–Leetcode刷题日记" class="headerlink" title="汇总–Leetcode刷题日记"></a>汇总–Leetcode刷题日记</h1><p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。 </p>
<p>示例 1：</p>
<p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对于每一个数，都可选可不选</p>
<pre><code class="cpp">//写法一，优先选择
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; combine;
    void dfs(vector&lt;int&gt;&amp; candidates, int target, int idx) &#123;
 
        if (target == 0) //基础情况
        &#123;
            ans.emplace_back(combine);
        &#125;
        else if (target &gt; 0 &amp;&amp; idx &lt; candidates.size())//可继续递归的情况
        &#123;
            // 直接跳过
            dfs(candidates, target,idx + 1);
            // 选择当前数
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx],idx);
            combine.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;

        dfs(candidates, target, 0);
        return ans;
    &#125;
&#125;;
</code></pre>
<pre><code class="cpp">//写法二
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; combine;
    void dfs(vector&lt;int&gt;&amp; candidates, int target, int idx) &#123;
        if (idx == candidates.size()) &#123;
            return;
        &#125;
        if (target == 0) &#123;
            ans.emplace_back(combine);
            return;
        &#125;
        // 直接跳过
        dfs(candidates, target,idx + 1);
        // 选择当前数
        if (target - candidates[idx] &gt;= 0) &#123;
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx],  idx);
            combine.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;

        dfs(candidates, target, 0);
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>示例 1:</p>
<p>输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]</p>
<h2 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h2><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; combine;
    //寻找下一个不同元素的下标
    int getNext(vector&lt;int&gt;&amp; candidates, int i)  
    &#123;
        int next = i;
        while (next &lt; candidates.size() &amp;&amp; candidates[next] == candidates[i])
        &#123;
            ++ next;
        &#125;
        return next;
    &#125;
    void dfs(vector&lt;int&gt;&amp; candidates, int target, int idx) &#123;
        if (target == 0)
        &#123;
            ans.emplace_back(combine);
        &#125;
        else if (target &gt; 0 &amp;&amp; idx &lt; candidates.size())
        &#123;
            // 直接跳过
            dfs(candidates, target,getNext(candidates, idx));
            // 选择当前数
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx],idx+1);
            combine.pop_back();
        &#125;
        
    &#125;
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        //首先排序,便于跳过相同元素
        sort(candidates.begin(), candidates.end());         
        dfs(candidates, target, 0);
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p>示例 1:</p>
<p>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。</p>
<h2 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h2><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; combine;
    vector&lt;int&gt; candidates; //使用的源数组

    void dfs(int n, int idx, int k) &#123;
 
        if (n == 0&amp;&amp;0==k) //基础情况
        &#123;
            ans.emplace_back(combine);
        &#125;
        else if (n &gt; 0 &amp;&amp; idx &lt; candidates.size()&amp;&amp; 0 &lt; k)//可继续递归的情况
        &#123;
            // 直接跳过
            dfs(n,idx + 1,k);
            // 选择当前数，目标和减去当前值，消耗一次选择k-1
            combine.emplace_back(candidates[idx]);
            dfs(n - candidates[idx],idx+1,k-1);
            combine.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
        
        for(int i=1;i&lt;10;++i)&#123;
            candidates.push_back(i);
        &#125;
        dfs(n, 0, k);
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>源数组无重复元素时，每个元素可选可不选；</p>
<p>源数组有重复元素时，需要先排序，跳过重复元素。</p>
<h1 id="Leetcode刷题日记46"><a href="#Leetcode刷题日记46" class="headerlink" title="Leetcode刷题日记46"></a>Leetcode刷题日记46</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums &#x3D; [1]<br>输出：[[1]]</p>
<h2 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h2><p>搜索问题的解，可以通过 <strong>遍历</strong> 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 <strong>搜索一个问题的所有的解</strong> ，通过深度优先遍历的思想实现。</p>
<h3 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h3><ul>
<li><p>共同点<br>用于求解多阶段决策问题。多阶段决策问题即：求解一个问题分为很多步骤（阶段）；每一个步骤（阶段）可以有多种选择。</p>
</li>
<li><p>不同点<br>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；<br>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</p>
</li>
</ul>
<h3 id="从全排列问题开始理解回溯算法"><a href="#从全排列问题开始理解回溯算法" class="headerlink" title="从全排列问题开始理解回溯算法"></a>从全排列问题开始理解回溯算法</h3><p>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p>
<p>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p>
<p>看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构。</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png"></p>
<p>说明：</p>
<p>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；<br>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p>
<p>设计状态变量</p>
<ul>
<li><p>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；</p>
</li>
<li><p>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 &#x3D;&#x3D;depth&#x3D;&#x3D;，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；</p>
</li>
<li><p>&#x3D;&#x3D;布尔数组 used&#x3D;&#x3D;，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</p>
</li>
</ul>
<p>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p>
<h3 id="通用模板写法"><a href="#通用模板写法" class="headerlink" title="通用模板写法"></a>通用模板写法</h3><pre><code class="cpp">//path[]用于存储不同的可能性,ans[]存储最后返回的答案，used[]用于判断nums[]数组的对应位置上的数字是否被选过了，解释一下，如果是used[i]=true,表示nums[i]已经被选过了，我们在接下来的回溯过程中不用考虑这个数字了，但是回溯我们要记得复原现场
class Solution &#123;
public:
    //变量区
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; used;

    //主函数
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
       int n=nums.size();
       for(int i=0;i&lt;nums.size();i++) used.push_back(false);//初始时nums[]的每个数字都没别选过，都是false
       dfs(0,nums);
       return ans;
    &#125;

    //辅函数
    void dfs(int depth,vector&lt;int&gt;&amp; nums)//u表示选到了path[]的第几个位置了
    &#123;
        if(depth==nums.size())//选完了，将path[]存入ans中
        &#123;
            ans.push_back(path);
            return;
        &#125;
        for(int i=0;i&lt;nums.size();i++)
        &#123;
            if(!used[i])//如果nums[i]未被选择过
            &#123;
                used[i]=true;
                path.push_back(nums[i]);//将nums[i]放入path中
                dfs(depth+1,nums);//进行下一层的搜索
                used[i]=false;//现场的还原
                path.pop_back();//现场的还原
            &#125;
        &#125;
    &#125;

&#125;;
</code></pre>
<h3 id="全排列专用写法"><a href="#全排列专用写法" class="headerlink" title="全排列专用写法"></a>全排列专用写法</h3><p>动态维护数组</p>
<pre><code class="cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt; &gt; res;
    vector&lt;int&gt; path;
    int len;

    void backtrack(int depth)&#123;
        // 所有数都填完了
        if (depth == len) &#123;
            res.emplace_back(path);
            return;
        &#125;
        for (int i = depth; i &lt; len; ++i) &#123;
            // 动态维护数组
            swap(path[i], path[depth]);
            // 继续递归填下一个数
            backtrack(depth + 1);
            // 撤销操作
            swap(path[i], path[depth]);
        &#125;
    &#125;
    
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        path=nums;
        len=nums.size();
        backtrack(0);
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="Leetcode刷题日记77"><a href="#Leetcode刷题日记77" class="headerlink" title="Leetcode刷题日记77"></a>Leetcode刷题日记77</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></p>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>示例 2：</p>
<p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]</p>
<h2 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h2><p>组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即 [1, 2, 3] 与 [1, 3, 2] 认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。</p>
<p>回溯算法首先需要画出递归树，不同的树决定了不同的代码实现。下面给出了两种画树的思路。</p>
<h3 id="根据搜索起点画出二叉树"><a href="#根据搜索起点画出二叉树" class="headerlink" title="根据搜索起点画出二叉树"></a>根据搜索起点画出二叉树</h3><p>既然是树形问题上的 深度优先遍历，因此首先画出树形结构。例如输入：n &#x3D; 4, k &#x3D; 2，我们可以发现如下递归结构：</p>
<ul>
<li><p>如果组合里有 1 ，那么需要在 [2, 3, 4] 里再找 1 个数；</p>
</li>
<li><p>如果组合里有 2 ，那么需要在 [3, 4] 里再找 1数。注意：这里不能再考虑 1，因为包含 1 的组合，在第 1 种情况中已经包含。</p>
</li>
</ul>
<p>依次类推（后面部分省略），以上描述体现的 递归 结构是：在以 n 结尾的候选数组里，选出若干个元素。画出递归结构如下图：</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1599488203-TzmCXb-image.png" alt="image.png"></p>
<p>说明：</p>
<ul>
<li><p>叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 path，它是一个列表，特别地，path 是一个栈；</p>
</li>
<li><p>每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start ，表示在区间 [begin, n] 里选出若干个数的组合；</p>
</li>
<li><p>可能有一些分支没有必要执行，<strong>搜索起点有上界</strong>可优化。</p>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt;ans;
    vector&lt;int&gt;path;
    void backtracking(int n,int k,int startindex)
    &#123;
        //当path数组大小等于k时 说明已经到叶子结点了
        if(path.size()==k) &#123;
            ans.push_back(path);//存入ans 终止递归
            return ;
        &#125;
        //如果for循环选择的起始位置之后的元素个数已经少于我们需要的元素个数那就没必要搜索了
        for(int i=startindex;i&lt;=n-(k-path.size())+1;i++)
        &#123;
            path.push_back(i);//处理结点
            backtracking(n,k,i+1);//递归：下一层搜索要从i+1开始
            path.pop_back();//撤销处理的结点
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
       ans.clear();
       path.clear();
       backtracking(n,k,1);
       return ans;
    &#125;
&#125;;
</code></pre>
<h3 id="按照每一个数选与不选画出二叉树（-x3D-x3D-思路简单，优先选择-x3D-x3D-）"><a href="#按照每一个数选与不选画出二叉树（-x3D-x3D-思路简单，优先选择-x3D-x3D-）" class="headerlink" title="按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）"></a>按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</h3><p>可以按照每一个数选与不选画出二叉树，二叉树最多 <code>n</code> 层。同样可以剪枝。剪枝的思路请见下图「剪枝条件 ② 的加强」。</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1599529810-ZFNnoz-image.png" alt="image.png"></p>
<p>画一个表格更容易看出边界条件。</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1599608961-nfzexs-image.png" alt="image.png"></p>
<pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; path;
    vector&lt;vector&lt;int&gt;&gt; ans;

    void dfs(int cur, int n, int k) &#123;
        // 剪枝：path 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 path
        if (path.size() + (n - cur + 1) &lt; k) &#123;
            return;
        &#125;
        // 记录合法的答案
        if (path.size() == k) &#123;
            ans.push_back(path);
            return;
        &#125;
        // 考虑选择当前位置
        path.push_back(cur);
        dfs(cur + 1, n, k);
        path.pop_back();
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        dfs(1, n, k);
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="相关题型"><a href="#相关题型" class="headerlink" title="相关题型"></a>相关题型</h2><h4 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><h4 id="40-组合总和-II-1"><a href="#40-组合总和-II-1" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><h4 id="216-组合总和-III-1"><a href="#216-组合总和-III-1" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><h1 id="Leetcode刷题日记79"><a href="#Leetcode刷题日记79" class="headerlink" title="Leetcode刷题日记79"></a>Leetcode刷题日记79</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></p>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例 1：</p>
<p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/word2.jpg" alt="img"></p>
<h2 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h2><p>写法一：</p>
<pre><code class="cpp">class Solution &#123;
public:
    bool find = false;
    vector&lt;vector&lt;bool&gt;&gt; visited;

    // 主函数
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        if (board.empty()) return false;
        int m = board.size(), n = board[0].size();
        visited=vector&lt;vector&lt;bool&gt;&gt;(m, vector&lt;bool&gt;(n, false));
        
        for (int i = 0; i &lt; m; ++i) &#123;
            for (int j = 0; j &lt; n; ++j) &#123;
                backtracking(i, j, board, word, 0);
            &#125; 
        &#125;
        return find;
    &#125;
    // 辅函数
    void backtracking(int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int pos) &#123;
        if (i &lt; 0 || i &gt;= board.size() || j &lt; 0 || j &gt;= board[0].size()) &#123;
            return; &#125;
        if (visited[i][j] || find || board[i][j] != word[pos]) &#123;
            return; &#125;
        if (pos == word.size() - 1) &#123;
            find = true;
            return; &#125;
        visited[i][j] = true; // 修改当前节点状态
        // 递归子节点
        backtracking(i + 1, j, board, word,pos + 1);
        backtracking(i - 1, j, board, word,pos + 1);
        backtracking(i, j + 1, board, word,pos + 1);
        backtracking(i, j - 1, board, word,pos + 1);
        visited[i][j] = false; // 回改当前节点状态 
    &#125;
&#125;;
</code></pre>
<p>写法二：</p>
<pre><code class="cpp">class Solution &#123;
public:
    // 主函数
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        for(int i = 0; i &lt; board.size(); i++)
            for(int j = 0; j &lt; board[i].size(); j++)
                if(dfs(board,word,0,i,j)) return true;
        return false;        
    &#125;
    int dx[4] = &#123;-1,0,1,0&#125;, dy[4] = &#123;0,1,0,-1&#125;; //方向数组
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word,int u,int x,int y)
    &#123;
        if(board[x][y] != word[u]) return false;
        if(u == word.size() - 1)   return true;
        char t = board[x][y];
        //不能回头
        board[x][y] = &#39;.&#39;;
        for(int i = 0; i &lt; 4; i++)
        &#123;
            int a = x + dx[i], b = y + dy[i];
            //出界或者走到已经搜索过的位置
            if(a &lt; 0 || a &gt;= board.size() || b &lt; 0 || b &gt;= board[0].size() || board[a][b] == &#39;.&#39;)  continue;
            if(dfs(board,word,u+1,a,b)) return true;
        &#125;
        board[x][y] = t;
        return false;
    &#125;
&#125;;
</code></pre>
<h1 id="Leetcode刷题日记126"><a href="#Leetcode刷题日记126" class="headerlink" title="Leetcode刷题日记126"></a>Leetcode刷题日记126</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a></p>
<p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; s<del>k</del> 这样的单词序列，并满足：</p>
<ul>
<li><p>每对相邻的单词之间仅有单个字母不同。</p>
</li>
<li><p>转换过程中的每个单词 s<del>i</del>（1 &lt;&#x3D; i &lt;&#x3D; k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</p>
</li>
<li><p>s<del>k</del> &#x3D;&#x3D; endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, s<del>k</del>] 的形式返回。</p>
</li>
</ul>
<p>示例 1：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]<br>解释：存在 2 种最短的转换序列：<br>“hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”<br>“hit” -&gt; “hot” -&gt; “lot” -&gt; “log” -&gt; “cog”    </p>
<p>示例 2：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：[]<br>解释：endWord “cog” 不在字典 wordList 中，所以不存在符合要求的转换序列。</p>
<h2 id="单向BFS-HashMap-回溯"><a href="#单向BFS-HashMap-回溯" class="headerlink" title="单向BFS + HashMap + 回溯"></a><strong>单向BFS</strong> + <strong>HashMap</strong> + <strong>回溯</strong></h2><p>本题要求的是 <strong>最短转换序列</strong>，看到最短首先想到的就是 <strong>广度优先搜索</strong>。但是本题没有给出显示的图结构，根据单词转换规则：把每个单词都抽象为一个顶点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。由于要求输出所有的最短路径，因此我们需要记录遍历路径，然后通过「回溯算法（深度优先遍历）」得到所有的最短路径。</p>
<p>常规 BFS 模版代码代码逻辑：</p>
<pre><code class="markdown">定义 层节点 容器
根节点 压入容器内
while (容器非空) &#123;
    获取容器内节点的个数（即当前处理层节点个数）
    for (当前层节点个数) &#123;
        从容器中获取一个节点
        按业务逻辑处理单个节点
        获取当前节点的 子节点 压入容器内
    &#125;
&#125;
</code></pre>
<p>细节：</p>
<ul>
<li><p>从一个单词出发，修改每一位字符，将它修改成为 a 到 z 中的所有字符，看看修改以后是不是在题目中给出的单词列表中；</p>
</li>
<li><p>有一些边的关系，由于不是最短路径上的边，不可以被记录下来。为此，我们这样做：为扩展出的单词记录附加的属性：层数。即下面代码中的 steps。如果当前的单词扩散出去得到的单词的层数在以前出现过，则不应该记录这样的边的关系。</p>
</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;

using namespace std;

class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt; &amp;wordList) &#123;
        vector&lt;vector&lt;string&gt;&gt; res;
        // 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」
        unordered_set&lt;string&gt; dict = &#123;wordList.begin(), wordList.end()&#125;;
        // 修改以后看一下，如果根本就不在 dict 里面，跳过
        if (dict.find(endWord) == dict.end()) &#123;
            return res;
        &#125;
        // 特殊用例处理
        dict.erase(beginWord);

        // 第 1 步：广度优先遍历建图
        // 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层
        unordered_map&lt;string, int&gt; steps = &#123;&#123;beginWord, 0&#125;&#125;;
        // 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系
        unordered_map&lt;string, set&lt;string&gt;&gt; from = &#123;&#123;beginWord, &#123;&#125;&#125;&#125;;//存储父节点
        int step = 0;
        bool found = false;
        queue&lt;string&gt; q = queue&lt;string&gt;&#123;&#123;beginWord&#125;&#125;;
        int wordLen = beginWord.length();
        while (!q.empty()) &#123;
            step++;
            int size = q.size();
            for (int i = 0; i &lt; size; i++) &#123;
                const string currWord = move(q.front());
                string nextWord = currWord;
                q.pop();
                // 将每一位替换成 26 个小写英文字母
                for (int j = 0; j &lt; wordLen; ++j) &#123;
                    const char origin = nextWord[j];
                    for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; ++c) &#123;
                        nextWord[j] = c;
                        if (steps[nextWord] == step) &#123;
                            from[nextWord].insert(currWord);
                        &#125;
                        if (dict.find(nextWord) == dict.end()) &#123;
                            continue;
                        &#125;
                        // 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除
                        dict.erase(nextWord);
                        // 这一层扩展出的单词进入队列
                        q.push(nextWord);
                        // 记录 nextWord 从 currWord 而来
                        from[nextWord].insert(currWord);
                        // 记录 nextWord 的 step
                        steps[nextWord] = step;
                        if (nextWord == endWord) &#123;
                            found = true;
                        &#125;
                    &#125;
                    nextWord[j] = origin;
                &#125;
            &#125;
            if (found) &#123;
                break;
            &#125;
        &#125;
        // 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部
        if (found) &#123;
            vector&lt;string&gt; Path = &#123;endWord&#125;;
            dfs(res, endWord, from, Path);
        &#125;
        return res;
    &#125;

    void dfs(vector&lt;vector&lt;string&gt;&gt; &amp;res, const string &amp;Node, unordered_map&lt;string, set&lt;string&gt;&gt; &amp;from,
             vector&lt;string&gt; &amp;path) &#123;
        if (from[Node].empty()) &#123;
            res.push_back(&#123;path.rbegin(), path.rend()&#125;);
            return;
        &#125;
        for (const string &amp;Parent: from[Node]) &#123;
            path.push_back(Parent);
            dfs(res, Parent, from, path);
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="双向-两边收缩-BFS"><a href="#双向-两边收缩-BFS" class="headerlink" title="双向(两边收缩)BFS"></a>双向(两边收缩)BFS</h2><p>由于本题起点和终点固定，所以可以从起点和终点同时开始进行双向广度优先搜索，可以进一步降低时间复杂度。</p>
<p>如果把上面单向BFS遍历的面积理解成一个 三角形。<br>那么双向BFS遍历的面积就是上面三角形里面的 菱形（右图蓝色部分）。<br>如图：</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1620184096-ymksOd-image.png" alt="image.png"></p>
<p>也就是双向BFS节省去了 红色 部分节点的遍历（相当于剪枝），遍历的节点更少，速度也就更快。</p>
<p>另一种理解方式：</p>
<ul>
<li><p>单向BFS：左点 右面，需要在 右面 找到一点，并找出路径与左点连成一条线</p>
</li>
<li><p>双向BFS：左点 右点，找出路径左右点连成一条线</p>
</li>
</ul>
<h3 id="双向BFS处理逻辑"><a href="#双向BFS处理逻辑" class="headerlink" title="双向BFS处理逻辑"></a>双向BFS处理逻辑</h3><p>基本和单向BFS处理逻辑是差不多的，以 层节点 为单位来处理节点业务逻辑。<br>只是当每一次层节点上的逻辑处理完后，再根据 两边 层节点的个数来优先选择处理那边。<br>优先处理 层节点 数更少的一边。（关键词：更少）<br>基本都是左进一层，换右进一层，再换左进一层…….这样两边缩进的方式</p>
<h3 id="本题双向BFS处理细节"><a href="#本题双向BFS处理细节" class="headerlink" title="本题双向BFS处理细节"></a>本题双向BFS处理细节</h3><h4 id="节点遍历逻辑："><a href="#节点遍历逻辑：" class="headerlink" title="节点遍历逻辑："></a>节点遍历逻辑：</h4><p>因为是2边同时向中间压缩的方式，没办法向上面单向BFS那样，以单层完整的转换路径作为节点的数据结构。<br>所以本题先使用 双向BFS 先建立好单词之间完整的 树型转换序关系。<br>再对此树型结构做回溯遍历，获取不同的转换序列。</p>
<h4 id="双向BFS退出条件："><a href="#双向BFS退出条件：" class="headerlink" title="双向BFS退出条件："></a>双向BFS退出条件：</h4><p>虽然是双向压缩，但是每次只处理一层的节点数，所以不会存在重复，或超过遍历的 层。<br>当遍历到左右层高差距为 1 时就退出。<br>也就是前层节点的 子节点 出现在另一层。</p>
<h4 id="树型-数据结构的建立："><a href="#树型-数据结构的建立：" class="headerlink" title="树型 数据结构的建立："></a>树型 数据结构的建立：</h4><p>为了方便，选用 HashMap 来做树型数据的容器。（也不是不能真的做像多叉树的那样，用指针搭建树型结构。只是重新定义结构，代码和逻辑会变得更复杂，没必要）<br>HashMap这种 Key&#x2F;Value 对的形式是具有递归的属性的，即Value里面的值，是别一个Key。</p>
<h4 id="数据保存："><a href="#数据保存：" class="headerlink" title="数据保存："></a>数据保存：</h4><p>注意代码里面的这句 reversed ? next[s].push_back(w) : next[w].push_back(s);<br>当是 左-&gt;右 遍历时，是以 父节点 为基准去转换成 子节点。（ w 为 KEY，s 为 VALUE）<br>当是 右-&gt;左 遍历时，因为反向遍历，是以子节点为基准，去转换成 父节点。（ s 为 KEY，w 为 VALUE）</p>
<pre><code class="cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end()), head&#123;beginWord&#125;, tail&#123;endWord&#125;;
        if(!dict.count(endWord)) return res;
        dict.erase(beginWord), dict.erase(endWord);
        unordered_map&lt;string, vector&lt;string&gt;&gt; next;
        bool reversed = false, found = false; // 一些初始化准备
        while (!head.empty()) &#123;
            unordered_set&lt;string&gt; temp; // 保存已转化过的 string
            for (const auto &amp;w : head) &#123; // 层 遍历
                string s = w;
                for (size_t i = 0; i &lt; s.size(); ++i) &#123; // 回溯查找子节点
                    char c = s[i];
                    for (char j = &#39;a&#39;; j &lt;= &#39;z&#39;; ++j) &#123;
                        s[i] = j;
                        if (tail.count(s)) &#123; // 退出条件
                            reversed ? next[s].push_back(w) : next[w].push_back(s);
                            found = true;
                        &#125;
                        if (dict.count(s)) &#123; // 保存已转换的子节点
                            reversed ? next[s].push_back(w) : next[w].push_back(s);
                            temp.insert(s);
                        &#125;
                    &#125;
                    s[i] = c;
                &#125;
            &#125;
            if (found) break; // 退出
            for (const auto &amp;w : temp) dict.erase(w); // 删除已转换的 string
            if (temp.size() &lt;= tail.size()) head = temp; // 根据左右层节点大小来切换遍历方向
            else &#123;
                reversed = !reversed;
                head = tail;
                tail = temp;
            &#125;
        &#125;
        if (found) &#123; // 根据上面双向BFS构建的树型数据结构来梳理出不同的转换序
            vector&lt;string&gt; path = &#123;beginWord&#125;;
            backtracking(beginWord, endWord, next, path, res); // 回溯算法的应用
        &#125;
        return res;
    &#125;

private:
    void backtracking(const string &amp;src, const string &amp;dst, unordered_map&lt;string,vector&lt;string&gt;&gt; &amp;next,
        vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123;
        if (src == dst) res.push_back(path);
        for (const auto &amp;w : next[src]) &#123; // 按 层 为单位回溯求不同的转换序
            path.push_back(w);
            backtracking(w, dst, next, path, res);
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="Leetcode刷题日记130"><a href="#Leetcode刷题日记130" class="headerlink" title="Leetcode刷题日记130"></a>Leetcode刷题日记130</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h4><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例 1：</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/xogrid.jpg" alt="img"></p>
<p>输入：board &#x3D; [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>示例 2：</p>
<p>输入：board &#x3D; [[“X”]]<br>输出：[[“X”]]</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本题给定的矩阵中有三种元素：</p>
<p>字母 X；<br>被字母 X 包围的字母 O；<br>没有被字母 X 包围的字母 O。<br>本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>
<p>注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p>
<p>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>最后我们遍历这个矩阵，对于每一个字母：<br>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</p>
<p>&#x3D;&#x3D;本题优先用DFS&#x3D;&#x3D;</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 <code>O</code> 修改为字母 <code>A</code>。</p>
<pre><code class="cpp">class Solution &#123;
public:
    int n, m;

    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;
        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#39;O&#39;) &#123;
            return;
        &#125;
        board[x][y] = &#39;A&#39;;
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    &#125;

    //主函数
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        n = board.size();
        if (n == 0) &#123;
            return;
        &#125;
        m = board[0].size();
        for (int i = 0; i &lt; n; i++) &#123;
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        &#125;
        for (int i = 1; i &lt; m - 1; i++) &#123;
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        &#125;
        for (int i = 0; i &lt; n; i++) &#123;
            for (int j = 0; j &lt; m; j++) &#123;
                if (board[i][j] == &#39;A&#39;) &#123;
                    board[i][j] = &#39;O&#39;;
                &#125; else if (board[i][j] == &#39;O&#39;) &#123;
                    board[i][j] = &#39;X&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 <code>O</code> 修改为字母 <code>A</code>。</p>
<pre><code class="cpp">class Solution &#123;
public:
    const int dx[4] = &#123;1, -1, 0, 0&#125;;
    const int dy[4] = &#123;0, 0, 1, -1&#125;;

    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        int n = board.size();
        if (n == 0) &#123;
            return;
        &#125;
        int m = board[0].size();
        queue&lt;pair&lt;int, int&gt;&gt; que;
        for (int i = 0; i &lt; n; i++) &#123;
            if (board[i][0] == &#39;O&#39;) &#123;
                que.emplace(i, 0);
                board[i][0] = &#39;A&#39;;
            &#125;
            if (board[i][m - 1] == &#39;O&#39;) &#123;
                que.emplace(i, m - 1);
                board[i][m - 1] = &#39;A&#39;;
            &#125;
        &#125;
        for (int i = 1; i &lt; m - 1; i++) &#123;
            if (board[0][i] == &#39;O&#39;) &#123;
                que.emplace(0, i);
                board[0][i] = &#39;A&#39;;
            &#125;
            if (board[n - 1][i] == &#39;O&#39;) &#123;
                que.emplace(n - 1, i);
                board[n - 1][i] = &#39;A&#39;;
            &#125;
        &#125;
        while (!que.empty()) &#123;
            int x = que.front().first, y = que.front().second;
            que.pop();
            for (int i = 0; i &lt; 4; i++) &#123;
                int mx = x + dx[i], my = y + dy[i];
                if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#39;O&#39;) &#123;
                    continue;
                &#125;
                que.emplace(mx, my);
                board[mx][my] = &#39;A&#39;;
            &#125;
        &#125;
        for (int i = 0; i &lt; n; i++) &#123;
            for (int j = 0; j &lt; m; j++) &#123;
                if (board[i][j] == &#39;A&#39;) &#123;
                    board[i][j] = &#39;O&#39;;
                &#125; else if (board[i][j] == &#39;O&#39;) &#123;
                    board[i][j] = &#39;X&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集这种数据结构好像大家不太常用，实际上很有用。并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。 而这道题我们其实求解的就是和边界的 OO 在一个连通区域的的问题。</p>
<p>并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。<br>并查集的主要操作有：</p>
<p>find(int m)：这是并查集的基本操作，查找 mm 的根节点。</p>
<p>isConnected(int m,int n)：判断 m，nm，n 两个点是否在一个连通区域。</p>
<p>union(int m,int n):合并 m，nm，n 两个点所在的连通区域。</p>
<h3 id="并查集模板（Java）"><a href="#并查集模板（Java）" class="headerlink" title="并查集模板（Java）"></a>并查集模板（Java）</h3><pre><code class="cpp">class UnionFind &#123;
    int[] parents;

    public UnionFind(int totalNodes) &#123;
        parents = new int[totalNodes];
        for (int i = 0; i &lt; totalNodes; i++) &#123;
            parents[i] = i;
        &#125;
    &#125;
        // 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.
    void union(int node1, int node2) &#123;
        int root1 = find(node1);
        int root2 = find(node2);
        if (root1 != root2) &#123;
            parents[root2] = root1;
        &#125;
    &#125;

    int find(int node) &#123;
        while (parents[node] != node) &#123;
            // 当前节点的父节点 指向父节点的父节点.
            // 保证一个连通区域最终的parents只有一个.
            parents[node] = parents[parents[node]];
            node = parents[node];
        &#125;

        return node;
    &#125;

    boolean isConnected(int node1, int node2) &#123;
        return find(node1) == find(node2);
    &#125;
&#125;
</code></pre>
<p>我们的思路是把所有边界上的 OO 看做一个连通区域。遇到 OO 就执行并查集合并操作，这样所有的 OO 就会被分成两类：</p>
<ul>
<li><p>和边界上的 OO 在一个连通区域内的。这些 OO 我们保留。</p>
</li>
<li><p>不和边界上的 OO 在一个连通区域内的。这些 OO 就是被包围的，替换。</p>
</li>
</ul>
<p>由于并查集我们一般用一维数组来记录，方便查找 parants，所以我们将二维坐标用 node 函数转化为一维坐标。</p>
<pre><code class="cpp">public void solve(char[][] board) &#123;
        if (board == null || board.length == 0)
            return;

        int rows = board.length;
        int cols = board[0].length;

        // 用一个虚拟节点, 边界上的O 的父节点都是这个虚拟节点
        UnionFind uf = new UnionFind(rows * cols + 1);
        int dummyNode = rows * cols;

        for (int i = 0; i &lt; rows; i++) &#123;
            for (int j = 0; j &lt; cols; j++) &#123;
                if (board[i][j] == &#39;O&#39;) &#123;
                    // 遇到O进行并查集操作合并
                    if (i == 0 || i == rows - 1 || j == 0 || j == cols - 1) &#123;
                        // 边界上的O,把它和dummyNode 合并成一个连通区域.
                        uf.union(node(i, j), dummyNode);
                    &#125; else &#123;
                        // 和上下左右合并成一个连通区域.
                        if (i &gt; 0 &amp;&amp; board[i - 1][j] == &#39;O&#39;)
                            uf.union(node(i, j), node(i - 1, j));
                        if (i &lt; rows - 1 &amp;&amp; board[i + 1][j] == &#39;O&#39;)
                            uf.union(node(i, j), node(i + 1, j));
                        if (j &gt; 0 &amp;&amp; board[i][j - 1] == &#39;O&#39;)
                            uf.union(node(i, j), node(i, j - 1));
                        if (j &lt; cols - 1 &amp;&amp; board[i][j + 1] == &#39;O&#39;)
                            uf.union(node(i, j), node(i, j + 1));
                    &#125;
                &#125;
            &#125;
        &#125;

        for (int i = 0; i &lt; rows; i++) &#123;
            for (int j = 0; j &lt; cols; j++) &#123;
                if (uf.isConnected(node(i, j), dummyNode)) &#123;
                    // 和dummyNode 在一个连通区域的,那么就是O；
                    board[i][j] = &#39;O&#39;;
                &#125; else &#123;
                    board[i][j] = &#39;X&#39;;
                &#125;
            &#125;
        &#125;
    &#125;

    int node(int i, int j) &#123;
        return i * cols + j;
    &#125;
&#125;
</code></pre>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k&gt;2) 间房屋，有两个选项：</p>
<p>偷窃第 k 间房屋，那么就不能偷窃第k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p>
<p>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</p>
<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p>
<p>用$ \textit{dp}[i] $表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：<br>$dp[i]&#x3D;max(dp[i−2]+nums[i],dp[i−1])$</p>
<p>边界条件为：</p>
<p>$dp[0]&#x3D;nums[0]$ 只有一间房屋，则偷窃该房屋 ；</p>
<p>$dp[1]&#x3D;max(nums[0],nums[1])$  只有两间房屋，选择其中金额较高的房屋进行偷窃 。</p>
<p>最终的答案即为 $dp[n−1]$，其中 $n$ 是数组的长度。</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1.PNG" alt="img"></p>
<pre><code class="cpp">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.empty()) &#123;
            return 0;
        &#125;
        int size = nums.size();
        if (size == 1) &#123;
            return nums[0];
        &#125;
        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i &lt; size; i++) &#123;
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        &#125;
        return dp[size - 1];
    &#125;
&#125;;
</code></pre>
<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<pre><code class="cpp">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.empty()) &#123;
            return 0;
        &#125;
        int size = nums.size();
        if (size == 1) &#123;
            return nums[0];
        &#125;
        int first = nums[0], second = max(nums[0], nums[1]);
        for (int i = 2; i &lt; size; i++) &#123;
            int temp = second;
            second = max(first + nums[i], second);
            first = temp;
        &#125;
        return second;
    &#125;
&#125;;
</code></pre>
<h1 id="Leetcode刷题日记257"><a href="#Leetcode刷题日记257" class="headerlink" title="Leetcode刷题日记257"></a>Leetcode刷题日记257</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p>
<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/paths-tree.jpg" alt="img"></p>
<h2 id="DFS显式回溯"><a href="#DFS显式回溯" class="headerlink" title="DFS显式回溯"></a>DFS显式回溯</h2><p>使用vector<int> 结构path来记录路径方便回溯。</int></p>
<pre><code class="cpp">class Solution &#123;
private:

    vector&lt;string&gt; result;
    vector&lt;int&gt; path;
    // DFS回溯
    void traversal(TreeNode* cur) &#123;
        path.push_back(cur-&gt;val);
        // 这才到了叶子节点
        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;
            string sPath;
            for (int i = 0; i &lt; path.size() - 1; i++) &#123;
                sPath += to_string(path[i]);
                sPath += &quot;-&gt;&quot;;
            &#125;
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        &#125;
        if (cur-&gt;left) &#123;
            traversal(cur-&gt;left);
            path.pop_back(); // 回溯
        &#125;
        if (cur-&gt;right) &#123;
            traversal(cur-&gt;right);
            path.pop_back(); // 回溯
        &#125;
    &#125;

public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        
        if (root == NULL) return result;
        traversal(root);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="DFS隐式回溯"><a href="#DFS隐式回溯" class="headerlink" title="DFS隐式回溯"></a>DFS隐式回溯</h2><p>注意在函数定义的时候void traversal(TreeNode* cur, string path, vector<string>&amp; result) ，定义的是string path，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。</string></p>
<pre><code class="cpp">class Solution &#123;
private:

    void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result) &#123;
        path += to_string(cur-&gt;val); // 中
        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;
            result.push_back(path);
            return;
        &#125;
        if (cur-&gt;left) traversal(cur-&gt;left, path + &quot;-&gt;&quot;, result); // 左
        if (cur-&gt;right) traversal(cur-&gt;right, path + &quot;-&gt;&quot;, result); // 右
    &#125;

public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;

    &#125;
&#125;;
</code></pre>
<p>或</p>
<pre><code class="cpp">class Solution &#123;
public:
    void construct_paths(TreeNode* root, string path, vector&lt;string&gt;&amp; paths) &#123;
        if (root != nullptr) &#123;
            path += to_string(root-&gt;val);
            if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;  // 当前节点是叶子节点
                paths.push_back(path);                              // 把路径加入到答案中
            &#125; else &#123;
                path += &quot;-&gt;&quot;;  // 当前节点不是叶子节点，继续递归遍历
                construct_paths(root-&gt;left, path, paths);
                construct_paths(root-&gt;right, path, paths);
            &#125;
        &#125;
    &#125;

    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; paths;
        construct_paths(root, &quot;&quot;, paths);
        return paths;
    &#125;
&#125;;
</code></pre>
<h1 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307. 区域和检索 - 数组可修改"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums ，请你完成两类查询。</p>
<p>其中一类查询要求 更新 数组 nums 下标对应的值<br>另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：</p>
<p>NumArray(int[] nums) 用整数数组 nums 初始化对象<br>void update(int index, int val) 将 nums[index] 的值 更新 为 val<br>int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], …, nums[right]）</p>
<p>示例 1：</p>
<p>输入：<br>[“NumArray”, “sumRange”, “update”, “sumRange”]<br>[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]<br>输出：<br>[null, 9, null, 8]</p>
<p>解释：<br>NumArray numArray &#x3D; new NumArray([1, 3, 5]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; 返回 1 + 3 + 5 &#x3D; 9<br>numArray.update(1, 2);   &#x2F;&#x2F; nums &#x3D; [1,2,5]<br>numArray.sumRange(0, 2); &#x2F;&#x2F; 返回 1 + 2 + 5 &#x3D; 8</p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>本题只涉及「单点修改」和「区间求和」，属于「树状数组」的经典应用。</p>
<p>树状数组涉及的操作有两个，复杂度均为 O(logn)：</p>
<p>void add(int x, int u)：含义为在 x 的位置增加 u（注意位置下标从 1 开始）；<br>int query(int x)：含义为查询从 [1, x]区间的和为多少（配合容斥原理，可实现任意区间查询）。</p>
<pre><code class="c">class NumArray &#123;
    vector&lt;int&gt; tr;
    int lowbit(int x) &#123;
        return x &amp; -x;
    &#125;
    void add(int x, int u) &#123;
        for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += u;
    &#125;
    int query(int x) &#123;
        int ans = 0;
        for (int i = x; i &gt; 0; i -= lowbit(i)) ans += tr[i];
        return ans;
    &#125;

    vector&lt;int&gt; nums;
    int n;
public:
    NumArray(vector&lt;int&gt;&amp; _nums) &#123;
        nums = _nums;
        n = nums.size();
        tr.resize(n + 10);
        for (int i = 0; i &lt; n; i++) add(i + 1, nums[i]);
    &#125;
    void update(int index, int val) &#123;
        add(index + 1, val - nums[index]);
        nums[index] = val;
    &#125;
    int sumRange(int left, int right) &#123;
        return query(right + 1) - query(left);
    &#125;
&#125;;
</code></pre>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>相比「树状数组」，另外一个更为进阶且通用的做法是使用「线段树」。</p>
<p>线段树的所有操作同样为 O(logn)，由于本题不涉及「区间修改」操作，因此我们的线段树只需要实现 pushup 操作（子节点往上更新父节点），而不需要实现用于懒标记的 pushdown 操作（父节点往下传递「更新」的操作）。</p>
<p>关于线段树设计的几种操作：</p>
<p>void build(int u, int l, int r)：含义为从编号为 u 的节点开始，构造范围为 [l,r][l,r] 的树节点；<br>void update(int u, int x, int v)：含义为从编号为 uu 的节点开始，在 xx 位置增加 v；<br>更具一般性（涉及区间修改）的操作应该为 void update(int u, int l, int r, int v)，代表在 [l, r]范围增加 v；<br>int query(int u, int l, int r)：含义为从编号为 uu 的节点开始，查询 [l, r]区间和为多少。<br>注意：对于编号为 u 的节点而言，其左子节点的编号为 u &lt;&lt; 1，其右节点的编号为 u &lt;&lt; 1 | 1。</p>
<p>代码（考虑为线段树增加 static 优化，样例个数较少，优化不明显）：</p>
<pre><code class="java">class NumArray &#123;
    Node[] tr;
    class Node &#123;
        int l, r, v;
        Node(int _l, int _r) &#123;
            l = _l; r = _r;
        &#125;
    &#125;
    void build(int u, int l, int r) &#123;
        tr[u] = new Node(l, r);
        if (l == r) return;
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid);
        build(u &lt;&lt; 1 | 1, mid + 1, r);
    &#125;
    void update(int u, int x, int v) &#123;
        if (tr[u].l == x &amp;&amp; tr[u].r == x) &#123;
            tr[u].v += v;
            return ;
        &#125;
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if (x &lt;= mid) update(u &lt;&lt; 1, x, v);
        else update(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    &#125;
    int query(int u, int l, int r) &#123;
        if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].v;
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        int ans = 0;
        if (l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
        if (r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
        return ans;
    &#125;
    void pushup(int u) &#123;
        tr[u].v = tr[u &lt;&lt; 1].v + tr[u &lt;&lt; 1 | 1].v;
    &#125;

    int[] nums;
    public NumArray(int[] _nums) &#123;
        nums = _nums;
        int n = nums.length;
        tr = new Node[n * 4];
        build(1, 1, n);
        for (int i = 0; i &lt; n; i++) update(1, i + 1, nums[i]);
    &#125;
    public void update(int index, int val) &#123;
        update(1, index + 1, val - nums[index]);
        nums[index] = val;
    &#125;
    public int sumRange(int left, int right) &#123;
        return query(1, left + 1, right + 1);
    &#125;
&#125;

作者：AC_OIer
链接：https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-ac_oier-zmbn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<pre><code class="c">class NumArray &#123;
    static int N = 30010;
    static Node[] tr = new Node[N * 4];
    class Node &#123;
        int l, r, v;
        Node(int _l, int _r) &#123;
            l = _l; r = _r;
        &#125;
    &#125;
    void build(int u, int l, int r) &#123;
        if (tr[u] == null) &#123;
            tr[u] = new Node(l, r);
        &#125; else &#123;
            tr[u].l = l; tr[u].r = r; tr[u].v = 0;
        &#125;
        if (l == r) return ;
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid);
        build(u &lt;&lt; 1 | 1, mid + 1, r);
    &#125;
    void update(int u, int x, int v) &#123;
        if (tr[u].l == x &amp;&amp; tr[u].r == x) &#123;
            tr[u].v += v;
            return ;
        &#125;
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if (x &lt;= mid) update(u &lt;&lt; 1, x, v);
        else update(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    &#125;
    int query(int u, int l, int r) &#123;
        if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].v;
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        int ans = 0;
        if (l &lt;= mid) ans += query(u &lt;&lt; 1, l, r);
        if (r &gt; mid) ans += query(u &lt;&lt; 1 | 1, l, r);
        return ans;
    &#125;
    void pushup(int u) &#123;
        tr[u].v = tr[u &lt;&lt; 1].v + tr[u &lt;&lt; 1 | 1].v;
    &#125;

    int[] nums;
    public NumArray(int[] _nums) &#123;
        nums = _nums;
        int n = nums.length;
        build(1, 1, n);
        for (int i = 0; i &lt; n; i++) update(1, i + 1, nums[i]);
    &#125;
    public void update(int index, int val) &#123;
        update(1, index + 1, val - nums[index]);
        nums[index] = val;
    &#125;
    public int sumRange(int left, int right) &#123;
        return query(1, left + 1, right + 1);
    &#125;
&#125;

作者：AC_OIer
链接：https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-ac_oier-zmbn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h2 id="相关题型-1"><a href="#相关题型-1" class="headerlink" title="相关题型"></a>相关题型</h2><p><a target="_blank" rel="noopener" href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a></p>
<h1 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p> <img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/pathsum3-1-tree.jpg" alt="img"></p>
<p>示例 1：</p>
<p>输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br>示例 2：</p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：3</p>
<h2 id="树的遍历-DFS"><a href="#树的遍历-DFS" class="headerlink" title="树的遍历 + DFS"></a>树的遍历 + DFS</h2><p>一个朴素的做法是搜索以每个节点为根的（往下的）所有路径，并对路径总和为 targetSumtargetSum 的路径进行累加统计。</p>
<p>使用 dfs1 来搜索所有节点，复杂度为 O(n)；在 dfs1 中对于每个当前节点，使用 dfs2 搜索以其为根的所有（往下的）路径，同时累加路径总和为 targetSum 的所有路径。</p>
<pre><code class="cpp">//有返回值的写法
class Solution &#123;
public:
    int rootSum(TreeNode* root, int targetSum) &#123;
        if (!root) &#123;
            return 0;
        &#125;

        int ret = 0;
        if (root-&gt;val == targetSum) &#123;
            ret++;
        &#125; 

        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);
        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);
        return ret;
    &#125;
    //主函数
    int pathSum(TreeNode* root, int targetSum) &#123;
        if (!root) &#123;
            return 0;
        &#125;
        
        int ret = rootSum(root, targetSum);
        ret += pathSum(root-&gt;left, targetSum);
        ret += pathSum(root-&gt;right, targetSum);
        return ret;
    &#125;
&#125;;
</code></pre>
<pre><code class="c">//没有返回值的写法
class Solution &#123;
public:
    int ans=0;//递归函数没有返回值，用变量累加记录答案
    //主函数
    int pathSum(TreeNode* root, int targetSum) &#123;
        if(!root)return 0;
        long sum=targetSum;   //算例里面的有的值比较变态，把变量改为long
        dfs(root,sum);
        pathSum(root-&gt;left,sum);  //要双重递归，因为可以从任意节点开始
        pathSum(root-&gt;right,sum);

        return ans;

    &#125;
    void dfs(TreeNode* root,long targetSum)&#123;
        if(!root)return ;
        targetSum-=root-&gt;val;
        if(targetSum==0)ans++;  //此处不能return,因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归

        dfs(root-&gt;left,targetSum);
        dfs(root-&gt;right,targetSum);

    &#125;
&#125;;
</code></pre>
<pre><code class="c">//没有返回值的写法，宫水三叶版本修改
class Solution &#123;
public:
    int ans=0,t;
    //主函数
    int pathSum(TreeNode* root, int targetSum) &#123;
        if(!root) return 0;
        t=targetSum;
        dfs(root,root-&gt;val);
        pathSum(root-&gt;left,t);
        pathSum(root-&gt;right,t);
        return ans;
    &#125;
    void dfs(TreeNode* root,long long val)&#123;
        if(val==t) ans+=1;
        //树DFS遍历时优先判断左右节点非空
        if(root-&gt;left) dfs(root-&gt;left,val+root-&gt;left-&gt;val);
        if(root-&gt;right) dfs(root-&gt;right,val+root-&gt;right-&gt;val);
    &#125;
&#125;;
</code></pre>
<h2 id="树的遍历-前缀和"><a href="#树的遍历-前缀和" class="headerlink" title="树的遍历 + 前缀和"></a>树的遍历 + 前缀和</h2><p>在「解法一」中，我们统计的是以每个节点为根的（往下的）所有路径，也就是说统计的是以每个节点为「路径开头」的所有合法路径。</p>
<p>本题的一个优化切入点为「路径只能往下」，因此如果我们转换一下，统计以每个节点为「路径结尾」的合法数量的话，配合原本就是「从上往下」进行的数的遍历（最完整的路径必然是从原始根节点到当前节点的唯一路径），相当于只需要在完整路径中找到有多少个节点到当前节点的路径总和为 targetSum。</p>
<p>于是这个树上问题彻底转换一维问题：求解从原始起点（根节点）到当前节点 b 的路径中，有多少节点 a 满足 sum[a…b] &#x3D; targetSum，由于从原始起点（根节点）到当前节点的路径唯一，因此这其实是一个「一维前缀和」问题。</p>
<p>具体的，我们可以在进行树的遍历时，记录下从原始根节点 root 到当前节点 cur 路径中，从 root 到任意中间节点 x 的路径总和，配合哈希表，快速找到满足以 cur 为「路径结尾」的、使得路径总和为 targetSum 的目标「路径起点」有多少个。</p>
<p>一些细节：由于我们只能统计往下的路径，但是树的遍历会同时搜索两个方向的子树。因此我们应当在搜索完以某个节点为根的左右子树之后，应当回溯地将路径总和从哈希表中删除，防止统计到跨越两个方向的路径。</p>
<pre><code class="c">//有返回值的写法
class Solution &#123;
public:
    unordered_map&lt;long long, int&gt; prefix;

    int dfs(TreeNode *root, long long curr, int targetSum) &#123;
        if (!root) &#123;
            return 0;
        &#125;

        int ret = 0;
        curr += root-&gt;val;
        if (prefix.count(curr - targetSum)) &#123;
            ret = prefix[curr - targetSum];
        &#125;

        prefix[curr]++;
        ret += dfs(root-&gt;left, curr, targetSum);
        ret += dfs(root-&gt;right, curr, targetSum);
        prefix[curr]--;

        return ret;
    &#125;

    int pathSum(TreeNode* root, int targetSum) &#123;
        prefix[0] = 1;
        return dfs(root, 0, targetSum);
    &#125;
&#125;;
</code></pre>
<pre><code class="c">//没有返回值的写法,
class Solution &#123;
public:
    map&lt;int, int&gt; mp;
    int target, ans;
    int pathSum(TreeNode* root, int targetSum) &#123;
        target = targetSum;
        mp[0] = 1;
        dfs(root, 0);
        return ans;
    &#125;

    void dfs(TreeNode* node, int sum) &#123;
        if (node == NULL)
            return;
        sum += node-&gt;val;//累加需要用long long，否则int溢出出错
        ans += mp[sum - target];//map中不存在的值将返回0
        //if (mp.find(sum) != mp.end()) mp[sum]++;
        //else mp[sum] = 1;
        mp[sum]++;
        dfs(node-&gt;left, sum);
        dfs(node-&gt;right, sum);
        mp[sum]--;
    &#125;
&#125;;
</code></pre>
<pre><code class="c">//没有返回值的写法，宫水三叶版本修改
class Solution &#123;
public:
    int ans=0,t;
    unordered_map&lt;int,int&gt; hash;
    //主函数
    int pathSum(TreeNode* root, int targetSum) &#123;
        if(!root) return 0;
        t=targetSum;
        hash[0]=1;//base
        dfs(root,root-&gt;val);
        return ans;
    &#125;
    void dfs(TreeNode* root,long long val)&#123;  //累加需要用long long，否则int溢出出错
        ans+=hash[val-t];
        hash[val]++;
        if(root-&gt;left)dfs(root-&gt;left,val+root-&gt;left-&gt;val);
        if(root-&gt;right)dfs(root-&gt;right,val+root-&gt;right-&gt;val);
        hash[val]--;
    &#125;
&#125;;
</code></pre>
<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/del_node_1.jpg" alt="img"></p>
<p>示例 1:</p>
<p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p>
<h2 id="DFS查找"><a href="#DFS查找" class="headerlink" title="DFS查找"></a>DFS查找</h2><p>二叉搜索树的三个特性：</p>
<ul>
<li><p>二叉搜索树的中序遍历的序列是递增排序的序列。中序遍历的遍历次序：Left -&gt; Node -&gt; Right。</p>
</li>
<li><p>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</p>
</li>
<li><p>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p>
</li>
</ul>
<pre><code class="cpp">//规范的官方题解，对树结构改变较小 
class Solution &#123;
public:
    //Successor 代表的是中序遍历序列的下一个节点
    int successor(TreeNode* root) &#123;
        root = root-&gt;right;
        while (root-&gt;left) root = root-&gt;left;
        return root-&gt;val;
    &#125;
    //Predecessor 代表的是中序遍历序列的前一个节点
    int predecessor(TreeNode* root) &#123;
        root=root-&gt;left;
        while (root-&gt;right) root=root-&gt;right;
        return root-&gt;val;
    &#125;
    TreeNode* deleteNode(TreeNode* root, int key) &#123;
        if (!root) return nullptr;
        if (root-&gt;val == key) &#123;
            if(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;return nullptr;&#125;
            else if(root-&gt;right)&#123;
                root-&gt;val= successor(root);
                root-&gt;right=deleteNode(root-&gt;right,root-&gt;val);
            &#125;
            else&#123;
                root-&gt;val=predecessor(root);
                root-&gt;left=deleteNode(root-&gt;left,root-&gt;val);
            &#125;
        &#125;
        else if(key&lt;root-&gt;val)&#123;
            root-&gt;left=deleteNode(root-&gt;left,key);
        &#125;
        else&#123;
            root-&gt;right=deleteNode(root-&gt;right,key);
        &#125;
        return root;
    &#125;
&#125;;
</code></pre>
<pre><code class="cpp">//简洁版，对树结构改变较大 
class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) 
    &#123;
        if (root == nullptr)    return nullptr;
        if (key &gt; root-&gt;val)    root-&gt;right = deleteNode(root-&gt;right, key);     // 去右子树删除
        else if (key &lt; root-&gt;val)    root-&gt;left = deleteNode(root-&gt;left, key);  // 去左子树删除
        else    // 当前节点就是要删除的节点
        &#123;
            if (! root-&gt;left)   return root-&gt;right; // 情况1，欲删除节点无左子
            if (! root-&gt;right)  return root-&gt;left;  // 情况2，欲删除节点无右子
            TreeNode* node = root-&gt;right;           // 情况3，欲删除节点左右子树都有，优先从右子树删除 
            while (node-&gt;left)          // 寻找欲删除节点右子树的最左节点
                node = node-&gt;left;
            node-&gt;left = root-&gt;left;    // 将欲删除节点的左子树成为其右子树的最左节点的左子树
            root = root-&gt;right;         // 欲删除节点的右子顶替其位置，节点被删除
        &#125;
        return root;    
    &#125;
&#125;;
</code></pre>
<pre><code class="cpp">//可能部分地方有误，未勘误
class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) &#123;
        //情况一，找到空结点，说明没有找到key
        if (!root) return NULL;

        //找到要删除结点key
        if (root-&gt;val == key) &#123;
            //情况二：key 结点左右子树都为空，直接删除
            if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;
                delete root;
                return NULL;
            &#125;
            //情况三：目标结点的左子树不为NULL，右子树为NULL
            if (root-&gt;left &amp;&amp; !root-&gt;right) &#123;
                TreeNode* deln = root;
                root = root-&gt;left;
                delete deln;
                return root;
            &#125;
            //情况四：目标结点的右子树不为NULL，左子树为NULL
            if (!root-&gt;left &amp;&amp; root-&gt;right) &#123;
                TreeNode* deln = root;
                root = root-&gt;right;
                delete deln;
                return root;
            &#125;
            //目标点的左右子树都不为空，左子树代替右子树中最小左子树的左结点
            if (root-&gt;left &amp;&amp; root-&gt;right) &#123;
                //找到右子树的最小左子树
                TreeNode* cur = root-&gt;right;//指针cur等价于root-&gt;right，修改一方另一方也相应修改（应该是同个地址所以取的内容相同）
                while (cur-&gt;left) &#123;
                    cur = cur-&gt;left;
                &#125;
                //修改删除结点后替代的新结点，即直接接到cur后面
                cur-&gt;left = root-&gt;left;
                //删除结点
                root = root-&gt;right;
                return root;
            &#125;
        &#125;
        //key结点在左
        if (key &lt; root-&gt;val )
            root-&gt;left = deleteNode(root-&gt;left, key);
        if(key &gt; root-&gt;val)
            root-&gt;right = deleteNode(root-&gt;right, key);

        return root;
    &#125;
&#125;;
</code></pre>
<h1 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目：684-冗余连接"><a href="#题目：684-冗余连接" class="headerlink" title="题目：684. 冗余连接"></a>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h2><p>树可以看成是一个连通且无环的无向图。</p>
<p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] &#x3D; [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p>
<p>示例 1：</p>
<p>输入: edges &#x3D; [[1,2], [1,3], [2,3]]<br>输出: [2,3]</p>
<p><img src="/2022/07/28/LeetCode/%E6%B1%87%E6%80%BB--Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/MyBlog\picbed\1626676174-hOEVUL-image.png" alt="img"></p>
<h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 n 个节点，则这棵树有 n−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 n。</p>
<p>树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。</p>
<p>可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p>
<p>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</p>
<p>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p>
<pre><code class="cpp">class Solution &#123;
public:
    //简化版并查集
    vector&lt;int&gt; parent;
    int Find(int x) &#123;
        if (parent[x] != x) &#123;
            parent[x] = Find(parent[x]);
        &#125;
        return parent[x];
    &#125;

    void Union(int x, int y) &#123;
        parent[Find(x)] = Find(y);
    &#125;

    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;
        int n = edges.size();
        parent.resize(n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            parent[i] = i;
        &#125;
        for (auto&amp; edge: edges) &#123;
            int x1 = edge[0], x2 = edge[1];
            if (Find(x1) != Find(x2)) &#123;
                Union(x1, x2);
            &#125; else &#123;
                return edge;
            &#125;
        &#125;
        return vector&lt;int&gt;&#123;&#125;;
    &#125;
&#125;;
</code></pre>
<h1 id="934-最短的桥"><a href="#934-最短的桥" class="headerlink" title="934. 最短的桥"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a></h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E2%80%93Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0"><span class="toc-text">汇总–Leetcode刷题日记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B046"><span class="toc-text">Leetcode刷题日记46</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与动态规划的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">从全排列问题开始理解回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">通用模板写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%93%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-text">全排列专用写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B077"><span class="toc-text">Leetcode刷题日记77</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E8%B5%B7%E7%82%B9%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">根据搜索起点画出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E9%80%89%E4%B8%8E%E4%B8%8D%E9%80%89%E7%94%BB%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88-x3D-x3D-%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9-x3D-x3D-%EF%BC%89"><span class="toc-text">按照每一个数选与不选画出二叉树（&#x3D;&#x3D;思路简单，优先选择&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B"><span class="toc-text">相关题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-1"><span class="toc-text">216. 组合总和 III</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B079"><span class="toc-text">Leetcode刷题日记79</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0126"><span class="toc-text">Leetcode刷题日记126</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91BFS-HashMap-%E5%9B%9E%E6%BA%AF"><span class="toc-text">单向BFS + HashMap + 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91-%E4%B8%A4%E8%BE%B9%E6%94%B6%E7%BC%A9-BFS"><span class="toc-text">双向(两边收缩)BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">双向BFS处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E5%8F%8C%E5%90%91BFS%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82"><span class="toc-text">本题双向BFS处理细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">节点遍历逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91BFS%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-text">双向BFS退出条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="toc-text">树型 数据结构的建立：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-text">数据保存：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0130"><span class="toc-text">Leetcode刷题日记130</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">130. 被围绕的区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%EF%BC%88Java%EF%BC%89"><span class="toc-text">并查集模板（Java）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0257"><span class="toc-text">Leetcode刷题日记257</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%98%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS显式回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%BA%AF"><span class="toc-text">DFS隐式回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B-1"><span class="toc-text">相关题型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">树的遍历 + DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">树的遍历 + 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E6%9F%A5%E6%89%BE"><span class="toc-text">DFS查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">题目：684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-text">934. 最短的桥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B2%9B%EF%BC%8CBFS%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-text">DFS找第一个岛，BFS找最短距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%89"><span class="toc-text">写法三</span></a></li></ol></li></ol></li></ol></div></p>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/202204171401601.jpg" alt="icon2"></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a></p>
<p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）</p>
<p>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p>
<p>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）</p>
<p>示例 1：</p>
<p>输入：A &#x3D; [[0,1],[1,0]]<br>输出：1<br>示例 2：</p>
<p>输入：A &#x3D; [[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：</p>
<p>输入：A &#x3D; [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p>
<h1 id="DFS找第一个岛，BFS找最短距离"><a href="#DFS找第一个岛，BFS找最短距离" class="headerlink" title="DFS找第一个岛，BFS找最短距离"></a>DFS找第一个岛，BFS找最短距离</h1><p>以下三种写法，进行比较，择优记忆。</p>
<h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><p>&#x3D;&#x3D;BFS常用来处理最短路径问题，或可达性问题&#x3D;&#x3D;<br>所以会想到运用BFS，因为只存在两片岛屿：</p>
<ul>
<li><p>可以先找到其中一片岛屿，运用DFS把它标识为2，与另一片岛屿进行区分，也防止重复遍历</p>
</li>
<li><p>在1的标识过程中，收集第一片岛屿附近的海洋（最近一层的海洋0），加入队列queue</p>
</li>
<li><p>BFS搜索队列，逐层往外“填海造陆”，直到遇到第二片岛屿</p>
</li>
</ul>
<p><img src="https://gitee.com/lin-xujie/pic-bed/raw/master/img/1638328692-YrAjMu-1.jpg" alt="1.jpg"></p>
<pre><code class="cpp">class Solution &#123;
private:
    queue&lt;pair&lt;int, int&gt;&gt; points;
    vector&lt;int&gt; direction = &#123;-1, 0, 1, 0, -1&#125;;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;
        grid[i][j] = 2;
        for (int k = 0; k &lt; 4; k++) &#123;
            int x = i + direction[k];
            int y = j + direction[k + 1];
            if (x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size()) &#123;
                if (grid[x][y] == 2) continue;
                if (grid[x][y] == 1) dfs(grid, x, y);
                // 收集这个岛屿附近的0
                if (grid[x][y] == 0) points.push(&#123;x, y&#125;);
            &#125;
        &#125;
    &#125;
public:
    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int m = grid.size();
        int n = grid[0].size();
        // 找到第一个岛屿
        bool isFind = false;
        for (int i = 0; i &lt; m; i++) &#123;
            if (isFind) break;
            for (int j = 0; j &lt; n; j++) &#123;
                if (grid[i][j] == 1) &#123;
                    // 调用dfs把这个岛屿都标志为2
                    dfs(grid, i, j);
                    isFind = true;
                    break;
                &#125;
            &#125;
        &#125;
        // 找另一个岛屿 BFS
        int res = 0;
        while (!points.empty()) &#123;
            int size = points.size();
            res++;
            while (size--) &#123;
                auto [x, y] = points.front();
                points.pop();
                // 把这一层的0全部填为2，再把外层的0再加入队列，逐层填陆地，直到碰到第二片岛屿
                for (int k = 0; k &lt; 4; k++) &#123;
                    int p = x + direction[k];
                    int q = y + direction[k + 1];
                    if (p &gt;= 0 &amp;&amp; p &lt; m &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; n) &#123;
                        if (grid[p][q] == 1) return res;
                        if (grid[p][q] == 2) continue;
                        points.push(&#123;p, q&#125;);
                        grid[p][q] = 2;
                    &#125;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><p>首先随机搜索，找到一个岛，然后使用DFS&#x2F;BFS将这个岛的所有1变成2，并将1旁边的0都收集起来，为下面的步骤做准备。随后，对每一个收集来的0进行BFS，直到找到第二个岛。</p>
<p>（耗时最少）</p>
<pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; direction&#123;-1, 0, 1, 0, -1&#125;;

    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;
        int m = A.size(), n = A[0].size();
        queue&lt;pair&lt;int, int&gt;&gt; points;
        //使用dfs寻找第一个岛屿，并把1变成2
        bool flipped = false;
        for (int i(0); i &lt; m; ++i) &#123;
            if (flipped) break;
            for (int j(0); j &lt; n; ++j) &#123;
                if (A[i][j] == 1) &#123;
                    dfs(points, A, m, n, i, j);
                    flipped = true;
                    break;
                &#125;
            &#125;
        &#125;
        //bfs寻找第二个岛屿，把过程中的0变成2
        int x, y;
        int level = 0;
        while (!points.empty()) &#123;
            ++level;
            int n_points = points.size();
            while (n_points--) &#123;
                auto [r, c] = points.front();
                points.pop();
                for (int k(0); k &lt; 4; ++k) &#123;
                    x = r + direction[k], y = c + direction[k + 1];
                    if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;
                        if (A[x][y] == 2) continue;
                        if (A[x][y] == 1)    return level;
                        points.push(&#123;x, y&#125;);
                        A[x][y] = 2;
                    &#125;
                &#125;
            &#125;
        &#125;
        return 0;
    &#125;

    void dfs(queue&lt;pair&lt;int, int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; grid, int m, int n,
            int i, int j) &#123;
        //先考察方向问题
        if (i &lt; 0 || j &lt; 0 || i == m || j == n || grid[i][j] == 2) return;
        //再考虑别的推出方式
        if (grid[i][j] == 0) &#123;
            points.push(&#123;i, j&#125;);
            return;
        &#125;
        grid[i][j] = 2;
        dfs(points, grid, m, n, i - 1, j);
        dfs(points, grid, m, n, i + 1, j);
        dfs(points, grid, m, n, i, j - 1);
        dfs(points, grid, m, n, i, j + 1);
    &#125;
&#125;;
</code></pre>
<h3 id="写法三"><a href="#写法三" class="headerlink" title="写法三"></a>写法三</h3><pre><code class="cpp">class Solution &#123;
public:
    int m, n, d[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;
    struct P&#123; int x, y, t;&#125;;
    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123;
        grid[x][y] = 2;
        for(int i=0;i&lt;4;i++)&#123; // 遍历4个邻接方向
            int xx=x+d[i][0], yy=y+d[i][1];
            if(xx&gt;=0 &amp;&amp; xx&lt;m &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;n &amp;&amp; grid[xx][yy]==1) // 新位置不越界且未被访问，DFS新位置
                DFS(grid, xx, yy);
        &#125;
    &#125;
    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        m=grid.size(), n=grid[0].size();
        bool flag = false; // 标记是否找到第一个岛
        queue&lt;P&gt; q;
        for(int i=0;i&lt;m;i++)&#123;
            for(int j=0;j&lt;n;j++)
                if(grid[i][j]==1)&#123;
                    if(!flag)&#123;
                        DFS(grid, i, j); // 找到第一个岛，将岛上格点全标记为2
                        flag = true;
                    &#125;else&#123; // 第二个岛的格点入队、初始距离置为0，并标记为已访问
                        q.emplace(P&#123;i, j, 0&#125;);
                        grid[i][j] = 1;
                    &#125;
                &#125;
        &#125;
        while(!q.empty())&#123;
            auto [x, y, t] = q.front();
            q.pop();
            for(int i=0;i&lt;4;i++)&#123; // 遍历4个邻接方向
                int xx=x+d[i][0], yy=y+d[i][1];
                if(xx&gt;=0 &amp;&amp; xx&lt;m &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;n &amp;&amp; grid[xx][yy]!=1)&#123; // 新位置不越界且未被访问
                    if(grid[xx][yy] == 2) // 新位置为第一个岛屿，返回当前距离
                        return t;
                    q.emplace(P&#123;xx, yy, t+1&#125;); // 新位置入队，距离+1
                    grid[xx][yy] = 1; // 标记新位置已访问
                &#125;
            &#125;  
        &#125;
        return 0;
    &#125;
&#125;;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1435359352@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>









    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2020-2022 lkjack
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
